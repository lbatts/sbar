---
title: "Schnute models"
author: "Luke Batts"
date: "`r Sys.Date()`"
output: rmarkdown::html_document
bibliography: sbar.bib
vignette: >
  %\VignetteIndexEntry{Schnunte models in more detail}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
options(rmarkdown.pdf_vignette.check_title = FALSE)
```
# Model aspects in more detail

In this vignette we will go into a little more detail into certain aspects of the Schnute models implemented within `sbar`.  To demonstrate these aspects we'll run through an assessment with the more complex Schnute adapted observation error model of black-bellied anglerfish stock introduced in the **introsbar** vignette

##Load the data and get mean weights matrix

In this example we'll also try to fit to an additional survey which is the IE-IAMS monkfish and megrim survey. This survey runs from 2006 to 2020 but has quite a few missing years.

Remember in the **introsbar** vignette we use the IBTS survey for mean weights as this is the closest to unbias mean weights estimates we can get. Catch is likely to be too biased. Also a reminder that there's no survey data for IBTS in 2017, this isn't an issue for this assessment with the survey observations but we still need a fully populated mean weight matrix, so we fill 2017 column with `rowMeans`.

```{r libraries data, echo=TRUE,message=FALSE,warning=FALSE}
library(sbar)
library(FLCore)
library(TMBhelper)
data("ank78")
data("ank78.indices")
years<-as.character(2003:2020) 
no.years<-length(years)
IBTS_PR_ages<-as.character(range(ank78.indices$FR_IE_IBTS)["min"]+1:range(ank78.indices$FR_IE_IBTS)["max"])
IEmon_full_ages<-ac(range(ank78.indices$IE_MONKSURVEY)["min"]:range(ank78.indices$IE_MONKSURVEY)["max"])
IEmon_yearrange<-ac(range(ank78.indices$IE_MONKSURVEY)["minyear"]:range(ank78.indices$IE_MONKSURVEY)["maxyear"])

Y <- c(quantSums(catch.wt(ank78)["0",years]*index(ank78.indices$FR_IE_IBTS)["0",years])/quantSums(index(ank78.indices$FR_IE_IBTS)[1,years]))
Z <- c(quantSums(catch.wt(ank78)[IBTS_PR_ages,years]*index(ank78.indices$FR_IE_IBTS)[IBTS_PR_ages,years])/quantSums(index(ank78.indices$FR_IE_IBTS)[IBTS_PR_ages,years]))
X <- c(quantSums(catch.wt(ank78)[,years]*index(ank78.indices$FR_IE_IBTS)[,years])/quantSums(index(ank78.indices$FR_IE_IBTS)[,years]))

mwts <- matrix(NA,ncol=no.years,nrow=3)
mwts[1,] <- Y
mwts[2,] <- Z
mwts[3,] <- X
mwts[,15] <- rowSums(mwts,na.rm=T)/(no.years-1)
```
## Growth and estimating growth parameters

If information on growth is available and weights-at-age are available these can be used (as is common for delay-difference models) to estimate growth parameters with a linear model, 

$$
\begin{aligned}
\bar{w}_{a+1} = W + \rho \bar{w}_{a} \\
\end{aligned}
$$

where $\bar{w}_a$ is the estimated weight-at-age and $\bar{w}_{a+1}$ is the weight-at-age a year older from sampling.

Another option, suggested as a check by @schnute1987, can be used to estimate growth parameters through estimation of a linear model on overall mean weights and previously-exploited stage mean weights from sampling:

$$
\begin{aligned}
X^{'}_t = W + \rho \bar{X_t} = \bar{Z}_{t+1} 
\end{aligned}
$$

This equation states that the entire population sampled mean weight $(\bar{X})$ in time _t_, after a year of growth, will be equivalent to the sampled mean weight of the previously-exploited population $(\bar{Z})$ in time _t+1_.  This relationship enables the estimation of the parameters _W_ and $\rho$  prior to assessment model by fitting a simple linear model where $\bar{X}_t$ and $\bar{Z}_{t+1}$ are generally calculated from the chosen weight intervals applied to sampling data.

We encourage users to try both these methods, however simulation testing indicated that the latter methodology to estimate growth parameters from $\bar{Z}$ and $\bar{X}$ is a better approximation of the deterministic growth assumed within the models. 

We estimate growth parameters like so,

```{r growth}
mod <- stats::lm(mwts[2,2:no.years]~mwts[3,1:no.years-1])
W1 <- coef(mod)[1]
rho1 <- coef(mod)[2]
```
visually this looks like:

```{r mwts plot2, echo = FALSE,fig.align='center'}
plot(X[-18], Z[-1],ylim=c(0,1.5),ylab="Z_t+1",xlab="X_t")#,xlim==c(0,3))
abline(c(W1, rho1))
legend("topright", legend = c("linear model"), col = 1, lty = 1,cex=0.5)
```

Next up we calculate total catch biomass from the FLStock and the biomass CPUE for the two surveys. It is unlikely these surveys do not have any selectivity differences over sizes or ages but these Schnute models assume the same catchability over the entire assessed population and offer no flexibility in the input.


```{r catch survey}
catch_biomass <- c(colSums(catch.n(ank78)[,years]*catch.wt(ank78)[,years],na.rm=T))
index1 <- colSums(index(ank78.indices$FR_IE_IBTS)*catch.wt(ank78)[,years],na.rm=T)
index2 <- colSums(index(ank78.indices$IE_MONKSURVEY)*catch.wt(ank78)[IEmon_full_ages,IEmon_yearrange],na.rm=T)

obs <- matrix(NA,nrow=2,ncol=no.years)
obs[1,]<-index1 # 
obs[2,4:no.years]<-index2 # 
obs[obs==0]<-NA
sigma_st <- exp(-0.25) # the accepted  stationary natural mortality of the stock is 0.25
```

At this point in the quick start Schnute in **introsbar** we just ran the function with this minimum amount of data with the default arguments. Here, we'll set up a list with data and arguments we want to set.

```{r list dat}
dat <- list( version = 2,
             catch_b = catch_biomass, 
             indices_b = obs, 
             ts = c(0.875,0.125), 
             mwts = mwts, 
             rho = rho1, 
             W = W1 , 
             start_q = c(1e-8, 2e-5),
             start_indexsigma = c(0.1, 0.2), 
             start_sigma = sigma_st, 
             start_f_calc = 0.5,
             fix_sigma = TRUE, 
             fix_indexsigma = FALSE)

```
Details of arguments can be found in the function documentation but things to note here:

* two survey timings (`ts`)
* two starting survey catchabilities (`start_q`)
* two starting survey SDs (`start_q`)
* starting value for fishing mortality estimates is 0.5 (`start_f_calc`)

and...`version` is set at 2. 

## version

An intriguing aspect of the model proposed in @schnute1987 is that there is three model versions, where a predicted total biomass index can be calculated a number of ways. Two of these model versions utilise all three time series of mean weights ($\bar{X}$, $\bar{Z}$ and $\bar{Y}$) to calculate $\omega_t$. $\omega_t$ is defined as the fraction of total biomass in year _t_ due to newly recruited fish,

$$
\begin{aligned}
\omega_t = \frac{R^*_t}{N^*_t}
\end{aligned}
$$
where $R^*_t$ is recruitment biomass at time _t_ and $N^*_t$ is population biomass at time _t_. @schnute1987 demonstrates that $\omega_t$ can be derived from mean weights alone:

$$
\begin{aligned}
\omega_t = \bigg(\frac{Y_t}{X_t}\bigg)\bigg(\frac{Z_t - X_t}{Z_t - Y_t}\bigg)
\end{aligned}
$$
$\omega_t$ values can then used to compute estimates of $N^*_t$ using only either the recruit stage $R^*_t$ (`version = 1`) or the previously exploited population stage $P^*_t$ (`version = 2`).

| version | $N^*_t$ calculation |
|:---:|:---------------:|
| 1 | $\frac{R^*_t}{\omega_t}$ | 
| 2 | $\frac{P^*_t}{1 - \omega_t}$ |
| 3 | $R^*_t + P^*_t$ |

`version = 3` is the more classical model form where estimated biomass in a given year is a combination of recruit biomass and previously exploited biomass.

These versions offer flexibility with the type of model you would like to fit. For example `version = 1` where the realtive importance is shifted to recruit biomass might be useful for a small pelagic stock where recruitment is a big driver of biomass changes. In terms of simplicity `version = 2` would be the preferred model as no recruitment parameters need to be estimated internally. Versions 1 and 3 fit a Beverton-Holt stock recruitment function internally in the model and these parameters can be difficult to estimate (as we'll see in the next section).


## version comparison

Lets load the data, with the thre versions. We'll use the default recruitment parameters and not mess around with proportion of biomass mature (`spawn_prop`).

```{r ver2 3 1,message=FALSE, warning=FALSE}
ver2<-do.call(schnute_obserror,dat)
dat$version = 1
ver1<-do.call(schnute_obserror,dat)
dat$version = 3
ver3<-do.call(schnute_obserror,dat)
```
Check model evaluate to a finite number with starting parameters

```{r evaluate}
ver1$fn(ver1$par)
ver2$fn(ver2$par)
ver3$fn(ver3$par)
```

All three do which is a good start. If they didn't then we would have to play around with starting parameters.






