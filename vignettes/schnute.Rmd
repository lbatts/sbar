---
title: "Schnute models"
author: "Luke Batts"
date: "`r Sys.Date()`"
output: rmarkdown::html_document
bibliography: sbar.bib
vignette: >
  %\VignetteIndexEntry{Schnunte models in more detail}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
options(rmarkdown.pdf_vignette.check_title = FALSE)
```
# Model aspects in more detail

In this vignette we will go into a little more detail into certain aspects of the Schnute models implemented within `sbar`.  To demonstrate these aspects we'll run through an assessment with the more complex Schnute adapted observation error model of black-bellied anglerfish stock introduced in the **introsbar** vignette

##Load the data and get mean weights matrix

In this example we'll also try to fit to an additional survey which is the IE-IAMS monkfish and megrim survey. This survey runs from 2006 to 2020 but has quite a few missing years.

Remember in the **introsbar** vignette we use the IBTS survey for mean weights as this is the closest to unbias mean weights estimates we can get. Catch is likely to be too biased. Also a reminder that there's no survey data for IBTS in 2017, this isn't an issue for this assessment with the survey observations but we still need a fully populated mean weight matrix, so we fill 2017 column with `rowMeans`.

```{r libraries data, echo=TRUE,message=FALSE,warning=FALSE}
library(sbar)
library(FLCore)
library(TMBhelper)
data("ank78")
data("ank78.indices")
years<-as.character(2003:2020) 
no.years<-length(years)
IBTS_PR_ages<-as.character(range(ank78.indices$FR_IE_IBTS)["min"]+1:range(ank78.indices$FR_IE_IBTS)["max"])
IEmon_full_ages<-ac(range(ank78.indices$IE_MONKSURVEY)["min"]:range(ank78.indices$IE_MONKSURVEY)["max"])
IEmon_yearrange<-ac(range(ank78.indices$IE_MONKSURVEY)["minyear"]:range(ank78.indices$IE_MONKSURVEY)["maxyear"])

Y <- c(quantSums(catch.wt(ank78)["0",years]*index(ank78.indices$FR_IE_IBTS)["0",years])/quantSums(index(ank78.indices$FR_IE_IBTS)[1,years]))
Z <- c(quantSums(catch.wt(ank78)[IBTS_PR_ages,years]*index(ank78.indices$FR_IE_IBTS)[IBTS_PR_ages,years])/quantSums(index(ank78.indices$FR_IE_IBTS)[IBTS_PR_ages,years]))
X <- c(quantSums(catch.wt(ank78)[,years]*index(ank78.indices$FR_IE_IBTS)[,years])/quantSums(index(ank78.indices$FR_IE_IBTS)[,years]))

mwts <- matrix(NA,ncol=no.years,nrow=3)
mwts[1,] <- Y
mwts[2,] <- Z
mwts[3,] <- X
mwts[,15] <- rowSums(mwts,na.rm=T)/(no.years-1)
```
## Growth and estimating growth parameters

If information on growth is available and weights-at-age are available these can be used (as is common for delay-difference models) to estimate growth parameters with a linear model, 

$$
\begin{aligned}
\bar{w}_{a+1} = W + \rho \bar{w}_{a} \\
\end{aligned}
$$

where $\bar{w}_a$ is the estimated weight-at-age and $\bar{w}_{a+1}$ is the weight-at-age a year older from sampling.

Another option, suggested as a check by @schnute1987, can be used to estimate growth parameters through estimation of a linear model on overall mean weights and previously-exploited stage mean weights from sampling:

$$
\begin{aligned}
X^{'}_t = W + \rho \bar{X_t} = \bar{Z}_{t+1} 
\end{aligned}
$$

This equation states that the entire population sampled mean weight $(\bar{X})$ in time _t_, after a year of growth, will be equivalent to the sampled mean weight of the previously-exploited population $(\bar{Z})$ in time _t+1_.  This relationship enables the estimation of the parameters _W_ and $\rho$  prior to assessment model by fitting a simple linear model where $\bar{X}_t$ and $\bar{Z}_{t+1}$ are generally calculated from the chosen weight intervals applied to sampling data.

We encourage users to try both these methods, however simulation testing indicated that the latter methodology to estimate growth parameters from $\bar{Z}$ and $\bar{X}$ is a better approximation of the deterministic growth assumed within the models. 

We estimate growth parameters like so,

```{r growth}
mod <- stats::lm(mwts[2,2:no.years]~mwts[3,1:no.years-1])
W1 <- coef(mod)[1]
rho1 <- coef(mod)[2]
```
visaully this looks like,

```{r mwts plot2, echo = FALSE,fig.align='center'}
plot(X[-18], Z[-1],ylim=c(0,1.5),ylab="Z_t+1",xlab="X_t")#,xlim==c(0,3))
abline(c(W1, rho1))
legend("topright", legend = c("linear model"), col = 1, lty = 1,cex=0.5)
```


```{r catch survey}
catch_kg <- c(colSums(catch.n(ank78)[,years]*catch.wt(ank78)[,years],na.rm=T))
index1 <- colSums(index(ank78.indices$FR_IE_IBTS)*catch.wt(ank78)[,years],na.rm=T)
index2 <- colSums(index(ank78.indices$IE_MONKSURVEY)*catch.wt(ank78)[IEmon_full_ages,IEmon_yearrange],na.rm=T)

obs <- matrix(NA,nrow=2,ncol=no.years)
obs[1,]<-index1 # 
obs[2,4:no.years]<-index2 # 
obs[obs==0]<-NA
sigma_st <- exp(-0.25) # the accepted  stationary natural mortality of the stock is 0.25
```

Lets load all the data and defined arguments for the assessment into a list





